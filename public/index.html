<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>üéÇ Sinh nh·∫≠t Th·∫£o ‚Äì 28/12</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: Arial, sans-serif;
    cursor: default;
  }

  #title {
    position: fixed;
    top: 6%;
    width: 100%;
    text-align: center;
    font-size: 26px;
    letter-spacing: 3px;
    color: #ff7aa2;
    text-shadow: 0 0 20px rgba(255,120,160,0.9);
    z-index: 10;
    opacity: 0;
    transition: opacity 1s;
  }

  #opening-text {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    color: #fff;
    text-align: center;
    opacity: 0;
    transition: opacity 3s;
    z-index: 15;
    text-shadow: 0 0 10px #ff7aa2, 0 0 20px #ff7aa2, 0 0 30px #ff7aa2;
    animation: glow 2s ease-in-out infinite alternate;
  }

  @keyframes glow {
    from {
      text-shadow: 0 0 10px #ff7aa2, 0 0 20px #ff7aa2, 0 0 30px #ff7aa2;
    }
    to {
      text-shadow: 0 0 20px #ff7aa2, 0 0 30px #ff7aa2, 0 0 40px #ff7aa2;
    }
  }

  #countdown {
    position: fixed;
    top: 12%;
    right: 5%;
    font-size: 18px;
    color: #ff7aa2;
    z-index: 10;
    opacity: 0;
    background: rgba(0,0,0,0.5);
    padding: 5px 10px;
    border-radius: 10px;
  }





  #popup input,
  #popup textarea {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border-radius: 8px;
    border: none;
  }

  #popup button {
    width: 100%;
    padding: 10px;
    background: #ff5f9e;
    color: #fff;
    border: none;
    border-radius: 10px;
    cursor: pointer;
  }

  #wish-button {
    position: fixed;
    bottom: 8%;
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 24px;
    background: rgba(255,95,158,0.8);
    color: #fff;
    border: none;
    border-radius: 25px;
    font-size: 16px;
    cursor: pointer;
    z-index: 20;
    opacity: 0;
    transition: opacity 1s;
  }

  .floating-wish {
    position: absolute;
    color: #fff;
    font-size: 14px;
    pointer-events: none;
    opacity: 0;
    background: rgba(255,95,158,0.8);
    padding: 10px 15px;
    border-radius: 20px;
    box-shadow: 0 0 10px rgba(255,120,160,0.5);
    max-width: 250px;
    word-wrap: break-word;
    animation: float 4s ease-in-out forwards;
    z-index: 25;
  }

  @keyframes float {
    0% { opacity: 0; transform: translateY(20px) scale(0.8); }
    10% { opacity: 1; transform: translateY(0) scale(1); }
    90% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-20px) scale(0.8); }
  }

  /* Mobile optimizations */
  @media (max-width: 768px) {
    #title {
      font-size: 18px;
      top: 4%;
    }

    #opening-text {
      font-size: 16px;
      padding: 0 20px;
    }

    #countdown {
      font-size: 12px;
      top: 10%;
      right: 5%;
      bottom: auto;
      left: auto;
    }

    #wish-button {
      bottom: 10%;
      padding: 10px 20px;
      font-size: 14px;
    }





    #wish-button {
      bottom: 10%;
      padding: 10px 20px;
      font-size: 14px;
    }
  }
</style>
</head>

<body>

<div id="opening-text"></div>
<div id="title">üíó Sinh nh·∫≠t Th·∫£o ¬∑ 28 ¬∑ 12 üíó</div>
<div id="countdown"></div>
<button id="wish-button">üíå G·ª≠i l·ªùi ch√∫c cho Th·∫£o </button>




<audio id="bg-music" loop>
  <source src="music.mp3" type="audio/mpeg">
  <!-- Replace with actual music file -->
</audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.124.0/build/three.min.js"></script>
<script>
/* ================= VARIABLES ================= */
let phase = -1; // -1: IDLE, 0: OPENING, 1: GATHERING, 2: CORE, 3: INTERACTION
let phaseStartTime = 0;
let wishes = [];
const audio = document.getElementById('bg-music');
const openingText = document.getElementById('opening-text');
const title = document.getElementById('title');
const countdownEl = document.getElementById('countdown');
const wishButton = document.getElementById('wish-button');
const popup = document.getElementById('popup');

/* ================= BASIC THREE SCENE ================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 50;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x000000);
document.body.appendChild(renderer.domElement);

/* ================= HEART PARTICLES ================= */
const heartParticles = [];
const heartGeo = new THREE.BufferGeometry();
const COUNT = 1000;
const pos = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);

// Heart outline points for constellation
const heartOutlineCount = 20;
const heartOutlinePoints = [];
for (let i = 0; i < heartOutlineCount; i++) {
  let t = (i / heartOutlineCount) * 2 * Math.PI;
  let x = 16 * Math.pow(Math.sin(t), 3) * 0.5;
  let y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.5;
  let z = 0;
  heartOutlinePoints.push(new THREE.Vector3(x, y, z));
}

// Target positions for full heart
const targetPos = new Float32Array(COUNT * 3);
for (let i = 0; i < COUNT; i++) {
  let t = Math.random() * 2 * Math.PI;
  let x = 16 * Math.pow(Math.sin(t), 3) * 0.5;
  let y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.5;
  let z = (Math.random() - 0.5) * 2;
  targetPos[i * 3] = x;
  targetPos[i * 3 + 1] = y;
  targetPos[i * 3 + 2] = z;
}

for (let i = 0; i < COUNT; i++) {
  // Start scattered
  pos[i * 3] = (Math.random() - 0.5) * 20;
  pos[i * 3 + 1] = (Math.random() - 0.5) * 20;
  pos[i * 3 + 2] = (Math.random() - 0.5) * 2;

  colors[i * 3] = 1;
  colors[i * 3 + 1] = 0.8;
  colors[i * 3 + 2] = 0.9; // Cool white
}

heartGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
heartGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const heartMat = new THREE.PointsMaterial({
  size: 0.6,
  vertexColors: true,
  transparent: true,
  opacity: 0.2,
  blending: THREE.AdditiveBlending
});

const heart = new THREE.Points(heartGeo, heartMat);
scene.add(heart);

// Constellation lines
const lineGeo = new THREE.BufferGeometry();
const lineMat = new THREE.LineBasicMaterial({ color: 0xff7aa2, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
const lines = new THREE.LineSegments(lineGeo, lineMat);
scene.add(lines);

/* ================= SNOW PARTICLES ================= */
const snowGeo = new THREE.BufferGeometry();
const snowCount = 100;
const snowPos = new Float32Array(snowCount * 3);
for (let i = 0; i < snowCount; i++) {
  snowPos[i * 3] = (Math.random() - 0.5) * 100;
  snowPos[i * 3 + 1] = Math.random() * 50 + 10;
  snowPos[i * 3 + 2] = (Math.random() - 0.5) * 50;
}
snowGeo.setAttribute("position", new THREE.BufferAttribute(snowPos, 3));
const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
const snow = new THREE.Points(snowGeo, snowMat);
scene.add(snow);

/* ================= TH·∫¢O'S IMAGE ================= */
const textureLoader = new THREE.TextureLoader();
const thaoTexture = textureLoader.load('https://via.placeholder.com/200x200?text=Thao'); // Replace with actual image URL
const thaoMat = new THREE.SpriteMaterial({ map: thaoTexture, transparent: true, opacity: 0.7 });
const thaoSprite = new THREE.Sprite(thaoMat);
thaoSprite.scale.set(5, 5, 1);
thaoSprite.position.set(0, 0, 0);
scene.add(thaoSprite);

/* ================= GLOWING DOT ================= */
const dotGeo = new THREE.SphereGeometry(0.5, 16, 16);
const dotMat = new THREE.MeshBasicMaterial({ color: 0xff7aa2, transparent: true, opacity: 0.8 });
const dot = new THREE.Mesh(dotGeo, dotMat);
dot.position.set(0, 0, 0);
scene.add(dot);

/* ================= PHASES ================= */
function initPhaseIdle() {
  phase = -1;
  phaseStartTime = Date.now();
  heart.visible = false;
  snow.visible = false;
  thaoSprite.visible = false;
  dot.visible = true;
  openingText.textContent = "Ch·∫°m ƒë·ªÉ b·∫Øt ƒë·∫ßu kho·∫£nh kh·∫Øc n√†y";
  openingText.style.opacity = 1;
  title.style.opacity = 0;
  wishButton.style.opacity = 0;
  countdownEl.style.opacity = 0;
}

function startPhaseOpening() {
  phase = 0;
  phaseStartTime = Date.now();
  dot.visible = false;
  heart.visible = false;
  snow.visible = false;
  thaoSprite.visible = false;
  openingText.textContent = "C√≥ nh·ªØng ng√†y‚Ä¶";
  openingText.style.opacity = 1;
  setTimeout(() => {
    openingText.textContent = "th·∫ø gi·ªõi b·ªóng d·ªãu d√†ng h∆°n.";
  }, 3000);
  setTimeout(() => {
    openingText.textContent = "28 ¬∑ 12 ¬∑ Th·∫£o";
  }, 6000);
  setTimeout(() => {
    openingText.style.opacity = 0;
  }, 9000);
}

function startPhaseGathering() {
  phase = 1;
  phaseStartTime = Date.now();
  heart.visible = true;
  heart.material.opacity = 0;
  snow.visible = false;
  thaoSprite.visible = false;
  openingText.style.opacity = 0;
}

function startPhaseCore() {
  phase = 2;
  phaseStartTime = Date.now();
  heart.material.opacity = 1;
  snow.visible = true;
  thaoSprite.visible = false;
  title.style.opacity = 1;
  title.textContent = "H√¥m nay\nl√† sinh nh·∫≠t em\nTh·∫£o üå∏";
  setTimeout(() => {
    title.textContent = "T·ª•i m√¨nh m·ªùi b·∫°n\nƒë·∫øn chung vui c√πng Th·∫£o";
  }, 8000);
}

function startPhaseInteraction() {
  phase = 3;
  phaseStartTime = Date.now();
  wishButton.style.opacity = 1;
  countdownEl.style.opacity = 1;
}

/* ================= LOAD WISHES ================= */
async function loadWishes() {
  const res = await fetch("/api/wishes");
  wishes = await res.json();
  wishes.forEach(w => spawnWishParticle(w.color));
}

/* ================= SPAWN PARTICLE ================= */
function spawnWishParticle(color) {
  const i = Math.floor(Math.random() * COUNT);
  const c = new THREE.Color(color);
  colors[i * 3] = c.r;
  colors[i * 3 + 1] = c.g;
  colors[i * 3 + 2] = c.b;
  heartGeo.attributes.color.needsUpdate = true;
}

/* ================= SUBMIT WISH ================= */
async function submitWish() {
  const name = document.getElementById("wish-name").value.trim();
  const message = document.getElementById("wish-msg").value.trim();
  if (!name || !message) return;

  // Hide popup immediately
  popup.style.display = 'none';
  document.getElementById("wish-msg").value = "";

  try {
    const res = await fetch("/api/wishes", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name, message })
    });

    if (res.ok) {
      const wish = await res.json();
      spawnWishParticle(wish.color);
    } else {
      alert("C√≥ l·ªói khi g·ª≠i l·ªùi ch√∫c. Vui l√≤ng th·ª≠ l·∫°i.");
      popup.style.display = 'block'; // Show back if error
    }
  } catch (error) {
    alert("L·ªói k·∫øt n·ªëi. Vui l√≤ng th·ª≠ l·∫°i.");
    popup.style.display = 'block';
  }
}



/* ================= COUNTDOWN ================= */
function updateCountdown() {
  const now = new Date();
  const birthday = new Date(now.getFullYear(), 11, 28); // Dec 28
  if (now > birthday) birthday.setFullYear(now.getFullYear() + 1);
  const diff = birthday - now;
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  countdownEl.textContent = `${days} ng√†y n·ªØa`;
}

/* ================= SHOW WISHES ================= */
function showWishes() {
  if (wishes.length === 0) return;
  wishes.forEach((w, index) => {
    setTimeout(() => {
      const floating = document.createElement('div');
      floating.className = 'floating-wish';
      floating.textContent = `${w.name}: ${w.message}`;
      floating.style.left = (Math.random() * 60 + 20) + '%';
      floating.style.top = (Math.random() * 50 + 20) + '%';
      document.body.appendChild(floating);
      setTimeout(() => document.body.removeChild(floating), 4000);
    }, index * 200); // Stagger by 200ms
  });
}
wishButton.addEventListener('click', () => {
  popup.style.display = 'block';
});

renderer.domElement.addEventListener('click', handleStart);
openingText.addEventListener('click', handleStart);

function handleStart() {
  if (phase === -1) {
    audio.volume = 0.3;
    audio.play();
    startPhaseOpening();
  }
}

/* ================= UPDATE SNOW ================= */
function updateSnow() {
  const positions = snowGeo.attributes.position.array;
  for (let i = 0; i < snowCount; i++) {
    positions[i * 3 + 1] -= 0.1;
    if (positions[i * 3 + 1] < -10) positions[i * 3 + 1] = 50;
  }
  snowGeo.attributes.position.needsUpdate = true;
}

/* ================= ANIMATE ================= */
let beatTime = 0;
function animate() {
  requestAnimationFrame(animate);
  const elapsed = (Date.now() - phaseStartTime) / 1000;

  if (phase === -1) {
    // Pulse the dot
    dot.scale.setScalar(1 + 0.2 * Math.sin(Date.now() * 0.005));
  } else if (phase === 0) {
    // Opening, no special animation
  } else if (phase === 1) {
    // Constellation Heart Formation
    const constellationProgress = Math.min(1, elapsed / 17);
    const positions = heartGeo.attributes.position.array;
    const colors = heartGeo.attributes.color.array;

    if (constellationProgress < 0.176) {
      // 2.1 Star Scatter (~3s)
      heart.material.opacity = 0.2;
      // Particles drift slightly
      for (let i = 0; i < COUNT; i++) {
        positions[i * 3] += Math.sin(Date.now() * 0.001 + i) * 0.01;
        positions[i * 3 + 1] += Math.cos(Date.now() * 0.001 + i) * 0.01;
      }
    } else if (constellationProgress < 0.47) {
      // 2.2 Constellation Reveal (~5s)
      const revealProgress = (constellationProgress - 0.176) / (0.47 - 0.176);
      heart.material.opacity = 0.2 + 0.3 * revealProgress;
      // Move outline particles to positions
      for (let i = 0; i < heartOutlineCount; i++) {
        positions[i * 3] += (heartOutlinePoints[i].x - positions[i * 3]) * 0.02;
        positions[i * 3 + 1] += (heartOutlinePoints[i].y - positions[i * 3 + 1]) * 0.02;
        positions[i * 3 + 2] += (heartOutlinePoints[i].z - positions[i * 3 + 2]) * 0.02;
        // Brighten outline particles
        colors[i * 3] = 1;
        colors[i * 3 + 1] = 0.6 + 0.4 * revealProgress;
        colors[i * 3 + 2] = 0.7 + 0.3 * revealProgress;
      }
      // Update lines
      const linePositions = [];
      for (let i = 0; i < heartOutlineCount; i++) {
        for (let j = i + 1; j < heartOutlineCount; j++) {
          if (heartOutlinePoints[i].distanceTo(heartOutlinePoints[j]) < 5) {
            linePositions.push(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
            linePositions.push(positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]);
          }
        }
      }
      lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
      lineMat.opacity = revealProgress * 0.5;
    } else if (constellationProgress < 0.647) {
      // 2.3 Connection Fade (~3s)
      const fadeProgress = (constellationProgress - 0.47) / (0.647 - 0.47);
      lineMat.opacity = 0.5 * (1 - fadeProgress);
      heart.material.opacity = 0.5 + 0.3 * fadeProgress;
    } else {
      // 2.4 Heart Solidification (~6s)
      const solidifyProgress = (constellationProgress - 0.647) / (1 - 0.647);
      heart.material.opacity = 0.8 + 0.2 * solidifyProgress;
      // Move all particles to heart positions
      for (let i = 0; i < COUNT; i++) {
        positions[i * 3] += (targetPos[i * 3] - positions[i * 3]) * 0.02;
        positions[i * 3 + 1] += (targetPos[i * 3 + 1] - positions[i * 3 + 1]) * 0.02;
        positions[i * 3 + 2] += (targetPos[i * 3 + 2] - positions[i * 3 + 2]) * 0.02;
        // Warm colors
        colors[i * 3] = 1;
        colors[i * 3 + 1] = 0.4 + 0.2 * solidifyProgress;
        colors[i * 3 + 2] = 0.6 + 0.2 * solidifyProgress;
      }
      lineMat.opacity = 0;
    }
    heartGeo.attributes.position.needsUpdate = true;
    heartGeo.attributes.color.needsUpdate = true;

    // Snow starts at ~5s
    if (elapsed > 5) {
      snow.visible = true;
      updateSnow();
    }
  } else if (phase === 2) {
    heart.rotation.y += 0.002;
    // Heartbeat
    beatTime += 0.05;
    let heartScale = 1 + 0.02 * Math.sin(beatTime);
    heart.scale.set(heartScale, heartScale, heartScale);
    // Animate snow
    updateSnow();
    // Thao image fade in at 3-7s
    if (elapsed > 3 && elapsed < 7) {
      thaoSprite.visible = true;
      thaoSprite.material.opacity = Math.min(0.7, (elapsed - 3) / 4);
    }
  } else if (phase === 3) {
    // Interaction, same as core
    heart.rotation.y += 0.002;
    beatTime += 0.05;
    let heartScale = 1 + 0.02 * Math.sin(beatTime);
    heart.scale.set(heartScale, heartScale, heartScale);
    updateSnow();
  }

  // Phase transitions
  if (phase === 0 && elapsed > 10) startPhaseGathering();
  if (phase === 1 && elapsed > 15) startPhaseCore(); // 10+15=25s
  if (phase === 2 && elapsed > 20) startPhaseInteraction(); // 25+20=45s

  renderer.render(scene, camera);
}

/* ================= INIT ================= */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

loadWishes();
updateCountdown();
setInterval(updateCountdown, 60000); // Update every minute
initPhaseIdle();
animate();

// Start showing wishes continuously
setInterval(() => {
  if (phase === 3 && wishes.length > 0) {
    const randomWish = wishes[Math.floor(Math.random() * wishes.length)];
    const floating = document.createElement('div');
    floating.className = 'floating-wish';
    floating.textContent = `${randomWish.name}: ${randomWish.message}`;
    floating.style.left = (Math.random() * 60 + 20) + '%';
    floating.style.top = (Math.random() * 50 + 20) + '%';
    document.body.appendChild(floating);
    setTimeout(() => document.body.removeChild(floating), 4000);
  }
}, 5000); // Every 5 seconds
</script>

</body>
</html>
